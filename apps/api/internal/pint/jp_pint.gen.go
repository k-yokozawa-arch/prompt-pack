// Package pint provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package pint

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AuditEntryAction.
const (
	InvoiceIssue    AuditEntryAction = "invoice.issue"
	InvoiceValidate AuditEntryAction = "invoice.validate"
)

// Defines values for InvoiceDraftCurrency.
const (
	JPY InvoiceDraftCurrency = "JPY"
)

// Defines values for InvoiceIssuedStatus.
const (
	InvoiceIssuedStatusDraft  InvoiceIssuedStatus = "draft"
	InvoiceIssuedStatusFailed InvoiceIssuedStatus = "failed"
	InvoiceIssuedStatusIssued InvoiceIssuedStatus = "issued"
)

// Defines values for InvoiceRecordStatus.
const (
	InvoiceRecordStatusDraft  InvoiceRecordStatus = "draft"
	InvoiceRecordStatusFailed InvoiceRecordStatus = "failed"
	InvoiceRecordStatusIssued InvoiceRecordStatus = "issued"
)

// Defines values for LineItemTaxCategory.
const (
	AE LineItemTaxCategory = "AE"
	E  LineItemTaxCategory = "E"
	G  LineItemTaxCategory = "G"
	K  LineItemTaxCategory = "K"
	O  LineItemTaxCategory = "O"
	S  LineItemTaxCategory = "S"
	Z  LineItemTaxCategory = "Z"
)

// Defines values for LineItemUnitCode.
const (
	D64 LineItemUnitCode = "D64"
	EA  LineItemUnitCode = "EA"
	HUR LineItemUnitCode = "HUR"
	KGM LineItemUnitCode = "KGM"
	LTR LineItemUnitCode = "LTR"
	MTR LineItemUnitCode = "MTR"
)

// Defines values for PartyCountryCode.
const (
	JP PartyCountryCode = "JP"
)

// Defines values for ValidationErrorItemSeverity.
const (
	Error   ValidationErrorItemSeverity = "error"
	Warning ValidationErrorItemSeverity = "warning"
)

// AuditEntry defines model for AuditEntry.
type AuditEntry struct {
	Action    AuditEntryAction   `json:"action"`
	Actor     string             `json:"actor"`
	AuditId   openapi_types.UUID `json:"auditId"`
	CorrId    string             `json:"corrId"`
	Hash      string             `json:"hash"`
	PrevHash  string             `json:"prevHash"`
	TenantId  string             `json:"tenantId"`
	Timestamp time.Time          `json:"timestamp"`
}

// AuditEntryAction defines model for AuditEntry.Action.
type AuditEntryAction string

// ConflictError defines model for ConflictError.
type ConflictError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// ForbiddenError defines model for ForbiddenError.
type ForbiddenError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// InternalError defines model for InternalError.
type InternalError struct {
	Code      string `json:"code"`
	Message   string `json:"message"`
	Retryable bool   `json:"retryable"`
}

// InvoiceDraft defines model for InvoiceDraft.
type InvoiceDraft struct {
	Currency      InvoiceDraftCurrency `json:"currency"`
	Customer      Party                `json:"customer"`
	DueDate       openapi_types.Date   `json:"dueDate"`
	InvoiceNumber *string              `json:"invoiceNumber,omitempty"`
	IssueDate     openapi_types.Date   `json:"issueDate"`
	Lines         []LineItem           `json:"lines"`
	Notes         *string              `json:"notes,omitempty"`
	Supplier      Party                `json:"supplier"`
}

// InvoiceDraftCurrency defines model for InvoiceDraft.Currency.
type InvoiceDraftCurrency string

// InvoiceIssued defines model for InvoiceIssued.
type InvoiceIssued struct {
	ExpiresAt *time.Time          `json:"expiresAt,omitempty"`
	InvoiceId openapi_types.UUID  `json:"invoiceId"`
	PdfUrl    *string             `json:"pdfUrl,omitempty"`
	Status    InvoiceIssuedStatus `json:"status"`

	// XmlUrl Signed URL valid for configured TTL
	XmlUrl string `json:"xmlUrl"`
}

// InvoiceIssuedStatus defines model for InvoiceIssued.Status.
type InvoiceIssuedStatus string

// InvoiceRecord defines model for InvoiceRecord.
type InvoiceRecord struct {
	Audit     *AuditEntry         `json:"audit,omitempty"`
	CreatedAt time.Time           `json:"createdAt"`
	InvoiceId openapi_types.UUID  `json:"invoiceId"`
	PdfUrl    *string             `json:"pdfUrl,omitempty"`
	Status    InvoiceRecordStatus `json:"status"`
	UpdatedAt time.Time           `json:"updatedAt"`
	XmlUrl    string              `json:"xmlUrl"`
}

// InvoiceRecordStatus defines model for InvoiceRecord.Status.
type InvoiceRecordStatus string

// LineItem defines model for LineItem.
type LineItem struct {
	Description string  `json:"description"`
	Quantity    float64 `json:"quantity"`

	// TaxCategory JP PINT tax category code
	TaxCategory LineItemTaxCategory `json:"taxCategory"`
	TaxRate     float64             `json:"taxRate"`

	// UnitCode UNECE unit code
	UnitCode  LineItemUnitCode `json:"unitCode"`
	UnitPrice float64          `json:"unitPrice"`
}

// LineItemTaxCategory JP PINT tax category code
type LineItemTaxCategory string

// LineItemUnitCode UNECE unit code
type LineItemUnitCode string

// NotFoundError defines model for NotFoundError.
type NotFoundError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// Party defines model for Party.
type Party struct {
	Address     string           `json:"address"`
	CountryCode PartyCountryCode `json:"countryCode"`
	Name        string           `json:"name"`
	Postal      string           `json:"postal"`

	// TaxId Japan TIN with leading T
	TaxId string `json:"taxId"`
}

// PartyCountryCode defines model for Party.CountryCode.
type PartyCountryCode string

// ValidationErrorItem defines model for ValidationErrorItem.
type ValidationErrorItem struct {
	Code     string                       `json:"code"`
	Message  string                       `json:"message"`
	Path     string                       `json:"path"`
	RuleId   string                       `json:"ruleId"`
	Severity *ValidationErrorItemSeverity `json:"severity,omitempty"`
}

// ValidationErrorItemSeverity defines model for ValidationErrorItem.Severity.
type ValidationErrorItemSeverity string

// ValidationErrorResponse defines model for ValidationErrorResponse.
type ValidationErrorResponse struct {
	Errors []ValidationErrorItem `json:"errors"`
}

// ValidationResponse defines model for ValidationResponse.
type ValidationResponse struct {
	Errors []ValidationErrorItem `json:"errors"`
	Totals *struct {
		GrandTotal *float64 `json:"grandTotal,omitempty"`
		Subtotal   *float64 `json:"subtotal,omitempty"`
		Tax        *float64 `json:"tax,omitempty"`
	} `json:"totals,omitempty"`
	Valid bool `json:"valid"`
}

// CorrelationId defines model for CorrelationId.
type CorrelationId = string

// TenantId defines model for TenantId.
type TenantId = string

// Forbidden defines model for Forbidden.
type Forbidden = ForbiddenError

// InvoiceIssuedResponse defines model for InvoiceIssuedResponse.
type InvoiceIssuedResponse = InvoiceIssued

// InvoiceRecordResponse defines model for InvoiceRecordResponse.
type InvoiceRecordResponse = InvoiceRecord

// ValidationCompleted defines model for ValidationCompleted.
type ValidationCompleted = ValidationResponse

// IssueInvoiceParams defines parameters for IssueInvoice.
type IssueInvoiceParams struct {
	// XCorrelationId Correlation ID for tracing and audit hash chain
	XCorrelationId CorrelationId `json:"X-Correlation-Id"`

	// XTenantId Tenant identifier for RBAC and storage segregation
	XTenantId TenantId `json:"X-Tenant-Id"`
}

// ValidateInvoiceParams defines parameters for ValidateInvoice.
type ValidateInvoiceParams struct {
	// XCorrelationId Correlation ID for tracing and audit hash chain
	XCorrelationId CorrelationId `json:"X-Correlation-Id"`

	// XTenantId Tenant identifier for RBAC and storage segregation
	XTenantId TenantId `json:"X-Tenant-Id"`
}

// GetInvoiceParams defines parameters for GetInvoice.
type GetInvoiceParams struct {
	// XCorrelationId Correlation ID for tracing and audit hash chain
	XCorrelationId CorrelationId `json:"X-Correlation-Id"`

	// XTenantId Tenant identifier for RBAC and storage segregation
	XTenantId TenantId `json:"X-Tenant-Id"`
}

// IssueInvoiceJSONRequestBody defines body for IssueInvoice for application/json ContentType.
type IssueInvoiceJSONRequestBody = InvoiceDraft

// ValidateInvoiceJSONRequestBody defines body for ValidateInvoice for application/json ContentType.
type ValidateInvoiceJSONRequestBody = InvoiceDraft

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Issue invoice and persist XML/PDF
	// (POST /invoices)
	IssueInvoice(w http.ResponseWriter, r *http.Request, params IssueInvoiceParams)
	// Validate invoice draft against JP PINT
	// (POST /invoices/validate)
	ValidateInvoice(w http.ResponseWriter, r *http.Request, params ValidateInvoiceParams)
	// Get invoice metadata and signed URLs
	// (GET /invoices/{id})
	GetInvoice(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvoiceParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Issue invoice and persist XML/PDF
// (POST /invoices)
func (_ Unimplemented) IssueInvoice(w http.ResponseWriter, r *http.Request, params IssueInvoiceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Validate invoice draft against JP PINT
// (POST /invoices/validate)
func (_ Unimplemented) ValidateInvoice(w http.ResponseWriter, r *http.Request, params ValidateInvoiceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get invoice metadata and signed URLs
// (GET /invoices/{id})
func (_ Unimplemented) GetInvoice(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetInvoiceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// IssueInvoice operation middleware
func (siw *ServerInterfaceWrapper) IssueInvoice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params IssueInvoiceParams

	headers := r.Header

	// ------------- Required header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = XCorrelationId

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-Id", Err: err})
		return
	}

	// ------------- Required header parameter "X-Tenant-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-Id")]; found {
		var XTenantId TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-Id", valueList[0], &XTenantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-Id", Err: err})
			return
		}

		params.XTenantId = XTenantId

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-Id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IssueInvoice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ValidateInvoice operation middleware
func (siw *ServerInterfaceWrapper) ValidateInvoice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ValidateInvoiceParams

	headers := r.Header

	// ------------- Required header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = XCorrelationId

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-Id", Err: err})
		return
	}

	// ------------- Required header parameter "X-Tenant-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-Id")]; found {
		var XTenantId TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-Id", valueList[0], &XTenantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-Id", Err: err})
			return
		}

		params.XTenantId = XTenantId

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-Id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ValidateInvoice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetInvoice operation middleware
func (siw *ServerInterfaceWrapper) GetInvoice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvoiceParams

	headers := r.Header

	// ------------- Required header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = XCorrelationId

	} else {
		err := fmt.Errorf("Header parameter X-Correlation-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Correlation-Id", Err: err})
		return
	}

	// ------------- Required header parameter "X-Tenant-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-Id")]; found {
		var XTenantId TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-Id", valueList[0], &XTenantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-Id", Err: err})
			return
		}

		params.XTenantId = XTenantId

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-Id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInvoice(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/invoices", wrapper.IssueInvoice)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/invoices/validate", wrapper.ValidateInvoice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/invoices/{id}", wrapper.GetInvoice)
	})

	return r
}
